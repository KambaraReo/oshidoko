name: Deploy to k3s

on:
  pull_request:
    branches: [main]
    types: [closed]
  workflow_dispatch: # 手動実行を可能にする

jobs:
  deploy:
    if: github.event.pull_request.merged == true || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: sakuraore/oshidoko:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: "v1.28.0"

      - name: Configure kubectl
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Deploy to k3s
        run: |
          # Apply Kubernetes manifests
          kubectl apply -f k8s/namespace.yaml
          kubectl apply -f k8s/configmap.yaml

          # Create secret dynamically (since secret.yaml is gitignored)
          kubectl create secret generic oshidoko-secret \
            --from-literal=GMAIL_SPECIFIC_PASSWORD="${{ secrets.GMAIL_SPECIFIC_PASSWORD }}" \
            --from-literal=MINIO_ACCESS_KEY="${{ secrets.MINIO_ACCESS_KEY }}" \
            --from-literal=MINIO_SECRET_KEY="${{ secrets.MINIO_SECRET_KEY }}" \
            --from-literal=MINIO_ROOT_USER="${{ secrets.MINIO_ROOT_USER }}" \
            --from-literal=MINIO_ROOT_PASSWORD="${{ secrets.MINIO_ROOT_PASSWORD }}" \
            --from-literal=MYAPP_DATABASE="${{ secrets.MYAPP_DATABASE }}" \
            --from-literal=MYAPP_DATABASE_USERNAME="${{ secrets.MYAPP_DATABASE_USERNAME }}" \
            --from-literal=MYAPP_DATABASE_PASSWORD="${{ secrets.MYAPP_DATABASE_PASSWORD }}" \
            --from-literal=MYAPP_DATABASE_HOST="${{ secrets.MYAPP_DATABASE_HOST }}" \
            --from-literal=RAILS_MASTER_KEY="${{ secrets.RAILS_MASTER_KEY }}" \
            --from-literal=GOOGLE_MAP_API_KEY="${{ secrets.GOOGLE_MAP_API_KEY }}" \
            --from-literal=SEND_MAIL="${{ secrets.SEND_MAIL }}" \
            --namespace oshidoko \
            --dry-run=client -o yaml | kubectl apply -f -
          kubectl apply -f k8s/mysql-deployment.yaml
          kubectl apply -f k8s/minio-deployment.yaml
          kubectl apply -f k8s/minio-ingress.yaml

          # Wait for dependencies
          kubectl wait --for=condition=ready pod -l app=mysql -n oshidoko --timeout=300s
          kubectl wait --for=condition=ready pod -l app=minio -n oshidoko --timeout=300s

          # Deploy Rails application
          kubectl apply -f k8s/rails-deployment.yaml
          kubectl apply -f k8s/ingress.yaml

          # Wait for Rails pods
          kubectl wait --for=condition=ready pod -l app=oshidoko-web -n oshidoko --timeout=300s

      - name: Initialize MinIO (if needed)
        run: |
          # Check if MinIO user already exists
          if ! kubectl exec -n oshidoko deployment/minio -- mc admin user list local | grep -q "minio_oshidokoak"; then
            kubectl exec -n oshidoko deployment/minio -- mc alias set local http://localhost:9000 admin adminpassword
            kubectl exec -n oshidoko deployment/minio -- mc admin user add local minio_oshidokoak minio_oshidokosk
            kubectl exec -n oshidoko deployment/minio -- mc admin policy attach local readwrite --user minio_oshidokoak
            kubectl exec -n oshidoko deployment/minio -- mc mb local/oshidoko-bucket --ignore-existing
            kubectl exec -n oshidoko deployment/minio -- mc anonymous set public local/oshidoko-bucket
          fi

      - name: Deployment Status
        run: |
          echo "Deployment completed successfully!"
          kubectl get pods -n oshidoko
          kubectl get ingress -n oshidoko
